name: CI/CD Pipeline
on:
  push: 
    branches:  
      - main

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: week5-lab-ecr-nicholas
  INFRASTRUCTURE_REPO: OppongNicholas303/S3-Image-Application-Infrastructure    
  STACK_NAME: S3AppStack 
  SERVICE_NAME: S3AppService
  CLUSTER_NAME: S3AppCluster
  DEPLOYMENT_GROUP: S3AppDeploymentGroup
  APPLICATION_NAME: S3AppCodeDeployApp
  CONTAINER_NAME: s3-app-container

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.build-image.outputs.image-tag }}
    steps:
      - name: Checkout application code
        uses: actions/checkout@v4
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4 
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Log in to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
        
      - name: Build and tag Docker image
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          IMAGE_TAG=$(date +%s)
          echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          
          docker build -t $ECR_REPOSITORY:$IMAGE_TAG .
          docker tag $ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker tag $ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
      - name: Push Docker image to ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

  infrastructure-deployment:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4 
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check if CloudFormation stack exists
        id: check-stack
        run: |
          if aws cloudformation describe-stacks --stack-name $STACK_NAME 2>&1 | grep -q "Stack with id $STACK_NAME does not exist"; then
            echo "stack_exists=false" >> $GITHUB_OUTPUT
          else
            echo "stack_exists=true" >> $GITHUB_OUTPUT
          fi

      - name: Checkout Infrastructure Repository
        if: steps.check-stack.outputs.stack_exists == 'false'
        uses: actions/checkout@v4
        with:
          repository: ${{ env.INFRASTRUCTURE_REPO }}
          path: infrastructure
          
      - name: Deploy or Update CloudFormation Stack
        env:
          ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
          IMAGE_TAG: ${{ needs.build-and-push.outputs.image-tag }}
        run: |
          aws cloudformation deploy \
            --template-file infrastructure/infastructure2.yaml \
            --stack-name $STACK_NAME \
            --parameter-overrides ImageUri=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM

  blue-green-deployment:
    needs: 
      - build-and-push
      - infrastructure-deployment
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4 
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Fetch Current Task Definition
        id: fetch-task-def
        env:
          ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
          IMAGE_TAG: ${{ needs.build-and-push.outputs.image-tag }}
        run: |
          # Attempt to get task definition from service
          TASK_DEF_ARN=$(aws ecs describe-services \
            --cluster $CLUSTER_NAME \
            --services $SERVICE_NAME \
            --query 'services[0].taskDefinition' \
            --output text)

          # Fetch full task definition details
          aws ecs describe-task-definition \
            --task-definition $TASK_DEF_ARN \
            --query 'taskDefinition' > task-definition.json

          # Prepare new task definition
          jq --arg image "$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" \
            '.containerDefinitions[0].image = $image' task-definition.json > new-task-def.json

      - name: Register New Task Definition
        id: register-task-def
        run: |
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --family $SERVICE_NAME \
            --requires-compatibilities FARGATE \
            --network-mode awsvpc \
            --cpu 2048 \
            --memory 4096 \
            --execution-role-arn $(jq -r '.executionRoleArn' task-definition.json) \
            --task-role-arn $(jq -r '.taskRoleArn' task-definition.json) \
            --container-definitions "$(jq '.containerDefinitions' new-task-def.json)" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          echo "TASK_DEF_ARN=$NEW_TASK_DEF_ARN" >> $GITHUB_ENV
          echo "New Task Definition ARN: $NEW_TASK_DEF_ARN"

      - name: Generate AppSpec File
        run: |
          cat > appspec.yaml <<EOF
          version: 0.0
          Resources:
            - TargetService:
                Type: AWS::ECS::Service
                Properties:
                  TaskDefinition: "${{ env.TASK_DEF_ARN }}"
                  LoadBalancerInfo:
                    ContainerName: "${{ env.CONTAINER_NAME }}"
                    ContainerPort: 3000
                  PlatformVersion: "LATEST"
          EOF

      - name: Deploy with CodeDeploy
        run: |
          DEPLOYMENT_ID=$(aws deploy create-deployment \
            --application-name $APPLICATION_NAME \
            --deployment-group-name $DEPLOYMENT_GROUP \
            --revision revisionType=AppSpecContent,appSpecContent="{content='$(cat appspec.yaml)'}" \
            --description "Automated deployment via GitHub Actions" \
            --query 'deploymentId' \
            --output text)

          echo "Deployment ID: $DEPLOYMENT_ID"
          
          # Wait for deployment and check status
          aws deploy wait deployment-successful --deployment-id $DEPLOYMENT_ID || {
            echo "Deployment failed"
            aws deploy get-deployment --deployment-id $DEPLOYMENT_ID
            exit 1
          }

  notify-on-failure:
    needs: 
      - build-and-push
      - infrastructure-deployment
      - blue-green-deployment
    if: failure()
    runs-on: ubuntu-latest
    steps:
      - name: Notification on Failure
        run: |
          echo "Deployment failed. Please check the GitHub Actions workflow logs."
          # You could add additional notification methods here (Slack, Email, etc.)
